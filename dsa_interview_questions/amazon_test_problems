def findHash(param):
    possible_remainders = []
    for p in param
        possible_remainders.extend(range(p))  
        print(possible_remainders)

# Example
param = [1, 2, 1, 3]
print(findHash(param))  # Output: 



this is the error problem


with Sorting time complexity : O(n log n) 
space complexity is :O(1) 


a = [1,2,1,3]
a.sort()

distinct_count = 0 
current_value = 0 

for i in a:
    if current_value < i:
        distinct_count +=1 
        current_value +=1 
print(distinct_count)






def findHash(param):
    max_val = max(param)  # Largest modulus value
    freq = [0] * (max_val + 1)  # Frequency array

    # Count how many boxes for each modulus value
    for p in param:
        freq[p] += 1

    distinct_count = 0   # Number of unique remainders found
    current_val = 0      # The next remainder we want

    # Process from smallest modulus to largest
    for p in range(1, max_val + 1):
        while freq[p] > 0 and current_val < p:
            distinct_count += 1    # Found a new remainder
            current_val += 1       # Move to next needed remainder
            freq[p] -= 1           # Use up one box of this size

    return distinct_count


# Example usage:
n = 4
param = [1, 2, 1, 3]
print(findHash(param))  # Output: 3


