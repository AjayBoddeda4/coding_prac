def insertion_sort(a):
    for i in range(1, len(a)-1):
        key = a[i]          
        j = i - 1
        
        while j >= 0 and a[j] > key:
            a[j + 1] = a[j]
            j -= 1
        a[j + 1] = key     
    return a

a = [12, 5, 7, 3, 15, 1, 9]
print(insertion_sort(a))



time complexity :O(n^2) 
space complexity :O(n^2) 




the algorithm easy explanation 

[12, 5, 7, 3, 15, 1, 9]


the insertion sort main motive just learning the algorithm is mostly enough dont need to learn the coding but better to know:


the insertion sort main motive is to add new element to the array in every iteration and comparing it with the previous elements 


let see this practical:

lets thing the size of the array is one : [12]  for this no need to sort 

now lets make it two : [12,5] now 5 is lesser then 12 so swap it [5,12] 

now lets make the size of the array three: [5,12,7] now compare the 3rd element with the next element 12 > 7 so swap [5,7,12] 

now lets make the size of the array four: [5,7,12,3] now check 12 > 3 swap 5,7,3,12  again 7 > 3 swap 5,3,7,12 check again 5 > 3 swap [3,5,7,12] 

now add the new item to the array: [3,5,7,12,15] check 12 > 15 no, so no swap 

now add one more element to the array : [3,5,7,12,15,1] now check 1 is less then any other element in the array so  swap 15 with 1 and 12 with 1 and 7 with 1 and 5 with 1 and 3 with 1 

the final array looks like : [ 1,3,5,7,12,15] 

now add the last element to the array :  [1,3,5,7,12,15,9] now compare 15 > 9 swap 12 > 9 swap ,7 < 9 so the 

final array is [1,3,5,7,9,12,15] 

this is the technique 

above code is the O(n^2) complexity 


with same complexity the code matching the logic with out confusion is :
a = [12, 5, 7, 3, 15, 1, 9]


for i in range(len(a)):
    for j in range(i,0,-1):
        if a[j] < a[j-1]:
            a[j],a[j-1] = a[j-1],a[j]
print(a)

this code swaps the elements so which is not so good 


so the first code is used which will replace the items to its position























 
